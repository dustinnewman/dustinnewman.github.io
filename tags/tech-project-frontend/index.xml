<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tech, project, frontend on Dustin Newman</title><link>https://dustinnewman.net/tags/tech-project-frontend/</link><description>Recent content in tech, project, frontend on Dustin Newman</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 03 Apr 2022 19:44:12 -0700</lastBuildDate><atom:link href="https://dustinnewman.net/tags/tech-project-frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>HFS+ to ext4</title><link>https://dustinnewman.net/posts/hfs-to-ext4/</link><pubDate>Mon, 13 Nov 2023 22:34:17 -0800</pubDate><guid>https://dustinnewman.net/posts/hfs-to-ext4/</guid><description>&lt;p>This is a straight-forward guide to copy a MacOS HFS+ filesystem partition to a Linux ext4 partition. When I looked online, I saw constant warnings and cautionary tales about how this is an inherently dangerous operation and you should never perform it. As I had a 5 TB hard drive sitting right in front me with only 1.2 TB used, the thought of purchasing a new hard drive because some risk is involved was ludicrous. After all, we are technologists. Transferring files from one file system to another should not raise so much handwringing.&lt;/p>
&lt;p>That said, here is your one and only warning if you decide to follow this guide. Any time you work with important data (and I assume any data you follow this guide for is important), you should have a backup. Even in &lt;code>$CURRENT_YEAR&lt;/code>, there is always a risk with data corruption or some hardware failure which prevents successful data transfer. If you do not make a backup, you have to be okay with total data loss. If you have any further objections than this, I assume you then know enough to do it a better and safer way. Note that you must have at least as much free space on your drive as you do used space e.g. if you are using 1 TB of data, you must have 1 TB free as well. With that out of the way, let&amp;rsquo;s get started.&lt;/p>
&lt;h2 id="on-your-mac">On your Mac&lt;/h2>
&lt;p>First, plug in the hard drive to your Mac. You should see your disk show up in the output of the &lt;code>diskutil list&lt;/code> command.&lt;/p>
&lt;pre>&lt;code class="language-sh">diskutil list
/dev/disk0 (internal, physical):
#: TYPE NAME SIZE IDENTIFIER
...
/dev/disk6 (external, physical):
#: TYPE NAME SIZE IDENTIFIER
0: GUID_partition_scheme *5.0 TB disk6
1: EFI EFI 209.7 MB disk6s1
2: Apple_HFS SEAGATE 5.0 TB disk6s2
&lt;/code>&lt;/pre>
&lt;p>In my case, I know I have a 5 TB hard drive, so it is listed as &lt;code>disk6&lt;/code>. We want to specifically deal with the &lt;code>disk6s2&lt;/code> partition. However, your disk will of course be different from mine. To avoid confusion, set the following shell variable, replacing the value with your disk identifier:&lt;/p>
&lt;pre>&lt;code class="language-sh">export DISK_ID=&amp;lt;YOUR DISK PARTITION&amp;gt;
# e.g. export DISK_ID=disk6s2
&lt;/code>&lt;/pre>
&lt;p>In my case, the entire 5 TB was allocated for the HFS+ file system. This is not going to work because I need two equal portions to transfer over the files: the existing one for HFS, and another one greater than or equal in size for ext4. So we have to resize the existing partition. If you have more than half your hard drive already used, &lt;strong>do not do this&lt;/strong>. &lt;strong>You will lose your data.&lt;/strong>&lt;/p>
&lt;p>For disk utility to allow us to resize, we have to make sure journaling is enabled.&lt;/p>
&lt;pre>&lt;code class="language-sh">diskutil enableJournal $DISK_ID
&lt;/code>&lt;/pre>
&lt;p>And now we can resize. In my case, I only had 1.2 TB occupied, so I will resize to 2 TB, making sure that we have enough space for the ext4 partition while not resulting in data loss of the existing HFS+ data.&lt;/p>
&lt;pre>&lt;code class="language-sh">diskutil resizeVolume disk6s2 2T
/dev/disk6 (external, physical):
#: TYPE NAME SIZE IDENTIFIER
0: GUID_partition_scheme *5.0 TB disk6
1: EFI EFI 209.7 MB disk6s1
2: Apple_HFS SEAGATE 2.0 TB disk6s2
(free space) 3.0 TB -
&lt;/code>&lt;/pre>
&lt;p>Now we need to disable journaling.&lt;/p>
&lt;pre>&lt;code class="language-sh">diskutil disableJournal disk6s2
&lt;/code>&lt;/pre>
&lt;p>And we can safely eject the drive. Note that we eject the entire disk, not the partition. Please replace the following with your actual disk.&lt;/p>
&lt;pre>&lt;code class="language-sh">diskutil eject &amp;lt;YOUR DISK&amp;gt;
# e.g. diskutil eject disk6
&lt;/code>&lt;/pre>
&lt;p>It is now time to unplug the disk from your Mac and plug it into your Linux device.&lt;/p>
&lt;h2 id="on-linux">On Linux&lt;/h2>
&lt;p>As always, make sure your system is up to date.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo apt-get update
&lt;/code>&lt;/pre>
&lt;p>We need the &lt;code>hfsprogs&lt;/code> program to work with the HFS file system on Linux systems. As its &lt;a href="https://packages.ubuntu.com/jammy/hfsprogs">package page&lt;/a> states, &lt;code>hfsprogs&lt;/code> is &amp;ldquo;mkfs and fsck for HFS and HFS+ file systems&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo apt-get install hfsprogs
&lt;/code>&lt;/pre>
&lt;p>You now need to get the disk information for your drive.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo fdisk -l
Device Start End Sectors Size Type
/dev/sda1 34 409633 409600 200M EFI System
/dev/sda2 411648 9767541133 9767129486 2T HFS / HFS+
&lt;/code>&lt;/pre>
&lt;p>For this portion, I even more highly recommend using shell variables to avoid mistakes since we are actively working with two different filesystems here, whereas before we only had one.&lt;/p>
&lt;pre>&lt;code class="language-sh">export HFS_DISK_ID=/dev/sda2
&lt;/code>&lt;/pre>
&lt;p>We check the integrity of the HFS+ filesystem with the &lt;code>fsck&lt;/code> from &lt;code>hfsprogs&lt;/code> (&lt;code>fsck.hfsplus&lt;/code>) and then unmount it, since it is never a good idea to operate on a mounted filesystem.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo fsck.hfsplus $HFS_DISK_ID
sudo umount $HFS_DISK_ID
&lt;/code>&lt;/pre>
&lt;p>Now time to finally create the new ext4 partition! We do this with the &lt;code>fdisk&lt;/code> command. &lt;code>fdisk&lt;/code> is used to manage disk partitions on Linux systems. It will open up a set of prompts requiring your input. I will list what to enter for each prompt.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo fdisk /dev/sda
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Command should be &lt;code>n&lt;/code> for new partition&lt;/li>
&lt;li>Partition number should be next after HFS partition, in my case, 3&lt;/li>
&lt;li>Start can be default to start right after existing HFS partition&lt;/li>
&lt;li>Size depends on your specifics. For me, it should be &lt;code>+2T&lt;/code> for 2 TB&lt;/li>
&lt;li>&lt;code>w&lt;/code> to write the command to disk&lt;/li>
&lt;/ul>
&lt;p>Woohoo! Our partition is created. Store it in an environment variable.&lt;/p>
&lt;pre>&lt;code class="language-sh">export EXT_DISK_ID=sda3
&lt;/code>&lt;/pre>
&lt;p>And now we need to actually make this partition use the ext4 filesystem.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo mkfs.ext4 $EXT_DISK_ID
&lt;/code>&lt;/pre>
&lt;p>In order to do anything with these filesystems, we need to mount them. The mount directory paths can be anything you want, but for simplicity I&amp;rsquo;d recommend just following these unless you have a good reason. These are where the environment variables really come in handy to avoid mixups.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo mkdir /mnt/hfsplus
sudo mkdir /mnt/ext4
sudo mount -t hfsplus -o force,rw $HFS_DISK_ID /mnt/hfsplus
sudo mount $EXT_DISK_ID /mnt/ext4
&lt;/code>&lt;/pre>
&lt;p>Now the actual transfer. For this, I used &lt;code>rsync&lt;/code>. Note that for my 1.2 TB, this transfer took 20 hours. The extended length of this transfer also increases the likelihood of hardware failure, network failure (which happened to me twice during this process), or power supply issues. Please take care to stabilize your system as much as possible.&lt;/p>
&lt;pre>&lt;code class="language-sh">sudo rsync -av /mnt/hfsplus/ /mnt/ext4/
&lt;/code>&lt;/pre></description></item><item><title>Rust Trait Coherence</title><link>https://dustinnewman.net/posts/rust-trait-coherence/</link><pubDate>Sat, 04 Nov 2023 16:36:26 -0700</pubDate><guid>https://dustinnewman.net/posts/rust-trait-coherence/</guid><description>&lt;h2 id="the-background">The Background&lt;/h2>
&lt;p>I defined a struct in a Rust project.&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Content
&lt;/code>&lt;/pre>
&lt;p>I then wanted an easy way to convert from different, other types into &lt;code>Content&lt;/code>, ideally staying within the Rust type system. My motivating example will be that you want to go from a file path to &lt;code>Content&lt;/code>. Since I am a good, active Rust user, I know that I don&amp;rsquo;t want to unnecessarily restrict my conversion function to only the concrete type &lt;code>Path&lt;/code> because the same logic applies to all sorts of &lt;code>Path&lt;/code>-like types e.g. &lt;code>PathBuf&lt;/code>, &lt;code>Components&lt;/code>, &lt;code>OsStr&lt;/code>, and even &lt;code>String&lt;/code>. So I implemented this trait generically.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P&amp;gt; TryFrom&amp;lt;P&amp;gt; for Content where P: AsRef&amp;lt;Path&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>The compiler threw an error message. This in itself is not too surprising: compiler errors are the bread and butter of Rust programming. But this particular compiler error threw me off guard.&lt;/p>
&lt;pre>&lt;code class="language-rust">conflicting implementation in crate `core`:
- impl&amp;lt;T, U&amp;gt; TryFrom&amp;lt;U&amp;gt; for T
where U: Into&amp;lt;T&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>This came as a bit of a shock to me because, well, I had just defined this struct &lt;code>Content&lt;/code>. How could Rust &lt;code>core&lt;/code> already have an implementation for it? To understand, we have to unpack what the generics in this type signature are really conveying. This type signature says that we have an implementation of &lt;code>TryFrom&lt;/code> &lt;em>from&lt;/em> any type &lt;code>&amp;lt;U&amp;gt;&lt;/code> &lt;em>for&lt;/em> any type &lt;code>&amp;lt;T&amp;gt;&lt;/code> if and only if &lt;code>&amp;lt;U&amp;gt;&lt;/code> already implements &lt;code>Into&amp;lt;T&amp;gt;&lt;/code>. Ok, when you put it like that, this actually seems quite reasonable. If we already have the logic to go from &lt;code>&amp;lt;U&amp;gt;&lt;/code> to &lt;code>&amp;lt;T&amp;gt;&lt;/code> infallibly, then surely we can represent this as a &amp;ldquo;fallible&amp;rdquo; operation, which simply returns &lt;code>Ok&lt;/code> all the time. And, in fact, when you look at the &lt;a href="https://github.com/rust-lang/rust/blob/f5ca57e153afaed818f8be88abf5ce46715c0f9a/library/core/src/convert/mod.rs#L800">Rust core source code&lt;/a>, this is exactly what it does.&lt;/p>
&lt;pre>&lt;code class="language-rust">// Infallible conversions are semantically equivalent to fallible conversions
// with an uninhabited error type.
#[stable(feature = &amp;quot;try_from&amp;quot;, since = &amp;quot;1.34.0&amp;quot;)]
impl&amp;lt;T, U&amp;gt; TryFrom&amp;lt;U&amp;gt; for T
where
U: Into&amp;lt;T&amp;gt;,
{
type Error = Infallible;
#[inline]
fn try_from(value: U) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
Ok(U::into(value))
}
}
&lt;/code>&lt;/pre>
&lt;p>Put this way, this seems not just reasonable but obvious. Of course, this makes sense. The issue I still didn&amp;rsquo;t understand though was that, sure, for any type &lt;code>&amp;lt;U&amp;gt;&lt;/code> if &lt;code>&amp;lt;U&amp;gt;&lt;/code> implements &lt;code>Into&amp;lt;T&amp;gt;&lt;/code> you can use this logical, &amp;ldquo;blanket&amp;rdquo; implementation to kind of vacuously implement &lt;code>TryFrom&amp;lt;U&amp;gt; for T&lt;/code>, &lt;em>but&lt;/em> my issue was that &lt;em>my&lt;/em> &lt;code>&amp;lt;U&amp;gt;&lt;/code> (&lt;code>P: AsRef&amp;lt;Path&amp;gt;&lt;/code>) &lt;strong>doesn&amp;rsquo;t&lt;/strong> implement &lt;code>Into&amp;lt;Content&amp;gt;&lt;/code>. So, why is Rust having an issue with this? And to answer it, we have to go into Rust &lt;strong>trait coherence&lt;/strong>.&lt;/p>
&lt;h2 id="trait-coherence">Trait Coherence&lt;/h2>
&lt;p>Trait coherence is &amp;ldquo;&lt;a href="https://github.com/Ixrec/rust-orphan-rules/blob/4b2ccb102bd7c715c4dc2ec4bdeaa96c6662093c/README.md?plain=1#L9">the property that there is at most one implementation of a trait for any given type&lt;/a>.&amp;rdquo; So, for example, you cannot have:&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Content;
impl Eq for Content
impl Eq for Content
&lt;/code>&lt;/pre>
&lt;p>Once again, when presented like this, this seems reasonable. Despite my confusion, I have to agree that the Rust compiler is making a sane assumption here. The issue, however, quickly becomes more complicated once you allow generics and crates (i.e. third-party code and dependencies). There are two often cited rules to help the Rust compiler enforce trait coherence.&lt;/p>
&lt;ol>
&lt;li>The Orphan Rule: Either the trait or the type for which you are implementing the trait must be local to your crate&lt;/li>
&lt;li>The Overlapping Rule: For any two types A and B implementing a trait T, A must be different from B&lt;/li>
&lt;/ol>
&lt;p>The orphan rule seems much more controversial and discussed online, but I believe my issue actually stems from the overlapping rule. Now, previously I gave an obviously wrong example to motivate why the Rust compiler even has a concept of trait coherence. But to motivate the overlapping rule, let&amp;rsquo;s give a &lt;a href="https://github.com/kennytm/rfcs/blob/a956323627bbc245dd3fe657f1dbc67060e77167/text/0000-negative-bounds.md">more realistic example&lt;/a> in order to steel-man the motivation. Let&amp;rsquo;s say that we have a trait to get the average of two numbers.&lt;/p>
&lt;pre>&lt;code class="language-rust">trait Int {}
trait Float {}
trait Average {
fn average(self, other: Self) -&amp;gt; Self;
}
&lt;/code>&lt;/pre>
&lt;p>We can implement this for &lt;code>Int&lt;/code> types:&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;T: Int&amp;gt; Average for T {
fn average(self, other: Self) -&amp;gt; Self {
if self &amp;gt;= other {
other + (self - other) / 2
} else {
self + (other - self) / 2
}
}
}
&lt;/code>&lt;/pre>
&lt;p>And then for &lt;code>Float&lt;/code> types:&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;T: Float&amp;gt; Average for T {
fn average(self, other: Self) -&amp;gt; Self {
self * 0.5 + other * 0.5
}
}
&lt;/code>&lt;/pre>
&lt;p>Uh-oh! Compiler error. The same as before. &lt;code>conflicting implementations of trait Average&lt;/code>. But&amp;hellip; why? We don&amp;rsquo;t really have two &lt;em>conflicting&lt;/em> implementations, as we have &lt;em>two&lt;/em> implementations. It seems as though Rust is unnecessarily strict here since there is no issue yet. Well, you see, I actually sort of underplayed the overlapping rule earlier. It really should be&lt;/p>
&lt;ol start="2">
&lt;li>The Overlapping Rule: For any two types A and B implementing a trait T, A must be &lt;strong>provably&lt;/strong> different from B &lt;strong>in every possible program&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>This is called &lt;a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">&amp;ldquo;negative reasoning&amp;rdquo;&lt;/a>. It is essentially the difference between saying &amp;ldquo;there does not exist any type which implements a trait twice &lt;em>currently&lt;/em>&amp;rdquo; and &amp;ldquo;there will &lt;em>never&lt;/em> exist any type which implements a trait twice.&amp;rdquo; Hopefully now it is more clear what the actual issue is. There is nothing specifically &lt;strong>stopping&lt;/strong> a type from implementing &lt;strong>both&lt;/strong> &lt;code>Int&lt;/code> and &lt;code>Float&lt;/code>. In the absence of this guarantee, Rust errs on the side of caution. And to Rust&amp;rsquo;s credit, this makes sense. Just look at the following, nothing seems wrong.&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Real
// Is this error?
impl Int for Real
// Or this?
impl Float for Real
&lt;/code>&lt;/pre>
&lt;p>If the compiler instead decided to follow the approach I preferred (don&amp;rsquo;t throw an error until a conflict actually exists), it would make implementating a trait an error. Not just an error, but a rather arbitrary error as well. In the example above, which implementation would you consider the &amp;ldquo;bad&amp;rdquo; one? There is no deterministic answer. This is not only unexpected, but would have breaking downstream consequences: a conflict may exist within other people&amp;rsquo;s crates because of a trait conflict that does &lt;strong>not&lt;/strong> exist on your system, but &lt;strong>does&lt;/strong> exist on theirs. This would be a huge disaster for the Rust ecosystem of crates, not to mention seriously hinder Rust&amp;rsquo;s changes of mainstream adoption. Looking at it from this perspective, it actually becomes clear why the Rust compiler decides to just play it safe and stop the problem at the root: a trait definition which could, theoretically, introduce an implementation conflict. This keeps the wider Rust ecosystem safe until a robust &amp;ldquo;fix&amp;rdquo;/solution is developed.&lt;/p>
&lt;p>But back to my original issue. You might recall that, unlike the previous example, there &lt;em>was no&lt;/em> more specific, conflicting example. I just wanted to implement&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P&amp;gt; TryFrom&amp;lt;P&amp;gt; for Content where P: AsRef&amp;lt;Path&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>It is not so much that there exists &amp;ldquo;two implementations&amp;rdquo; for &lt;code>TryFrom for Content&lt;/code>. It is moreso that currently Rust cannot guarantee that there will never be a type which satisfies two implementations. For example, if someone were to implement &lt;code>TryFrom&amp;lt;String&amp;gt;&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl TryFrom&amp;lt;String&amp;gt; for Content
&lt;/code>&lt;/pre>
&lt;p>This would introduce two valid implementations: one for the generic type &lt;code>P: AsRef&amp;lt;Path&amp;gt;&lt;/code> (which &lt;code>String&lt;/code> satisfies) and another for the specific type &lt;code>String&lt;/code>. Similarly, you could imagine we have a trait to calculate the last modified time of a file path.&lt;/p>
&lt;pre>&lt;code class="language-rust">trait LastModified {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime;
}
&lt;/code>&lt;/pre>
&lt;p>For all regular files, this is simple. Just take the modified time (&lt;code>mtime&lt;/code>).&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt; LastModified for P {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime {
fs::metadata(self.as_ref())
.and_then(|metadata| metadata.modified())
.unwrap_or(SystemTime::UNIX_EPOCH)
}
}
&lt;/code>&lt;/pre>
&lt;p>But for directories, the &lt;code>mtime&lt;/code> might not be exactly what we want. It most likely will be the last time a file or subdirectory was added or removed from the directory, rather than the last time a file or subdirectory was actually &lt;em>modified&lt;/em>. To fix this, we would have to make a special implementation just for directories.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl LastModified for ReadDir {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime {
self.filter_map(Result::ok)
.map(|entry| entry.path())
.filter_map(|path| fs::metadata(&amp;amp;path).ok())
.filter_map(|metadata| metadata.modified().ok())
.max()
.unwrap_or(SystemTime::UNIX_EPOCH)
}
}
&lt;/code>&lt;/pre>
&lt;p>So which one to choose? Currently, there is no way, and doing so would require a feature called &amp;ldquo;specialization&amp;rdquo;.&lt;/p>
&lt;p>There are a few options here:&lt;/p>
&lt;ol>
&lt;li>Extend Rust to supportive &amp;ldquo;negative&amp;rdquo; trait bounds (i.e. &lt;code>P: AsRef&amp;lt;Path&amp;gt; &amp;amp;! ContentNode: TryFrom&amp;lt;P&amp;gt;&lt;/code>) to allow the compiler to guarantee one implementation per type&lt;/li>
&lt;li>Allow multiple implementations per type and design a mechanism for deciding between them (&amp;ldquo;specialization&amp;rdquo;)&lt;/li>
&lt;li>Allow users to specify a crate locality condition that this crate will never be used by any other crate and thus we can bypass this condition just between us&lt;/li>
&lt;li>Just use &lt;code>PathBuf&lt;/code> here instead of generics&lt;/li>
&lt;/ol>
&lt;p>For now, I&amp;rsquo;m sticking with number four.&lt;/p></description></item><item><title>Farsi Ezafe Trick for L1 English Speakers</title><link>https://dustinnewman.net/posts/farsi-ezafe-trick/</link><pubDate>Sat, 28 Oct 2023 12:14:06 -0700</pubDate><guid>https://dustinnewman.net/posts/farsi-ezafe-trick/</guid><description>&lt;p>I recently came across a neat trick in &lt;em>Modern Persian&lt;/em> by Narguess Farzad (2004) for an intuition on the order of adjectives and possessives in Farsi (Iranian Persian). As an L1 English speaker, it can be difficult to get an intuition for the adjective order (postpositional) and how that works with the possessives in Farsi (also postpositional).&lt;/p>
&lt;p>You simply write the English phrase as usual: left to right. Then underneath you write the Farsi translation: right to left. Because adjectives and possessives are postpositional, but Farsi is also written right to left, the two &amp;ldquo;reverse&amp;rdquo; and provide a simple way to get the correct word order in Farsi. Farzad provides the simple example:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>blue&lt;/td>
&lt;td>pencil&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>آبی&lt;/td>
&lt;td>مداد&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>Because possessive adjectives follow attributive adjectives, this extends to genitive constructions as well:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>my&lt;/td>
&lt;td>brother's&lt;/td>
&lt;td>hand&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>من&lt;/td>
&lt;td>برادر&lt;/td>
&lt;td>دست&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>And to multiple adjectives:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>cold&lt;/td>
&lt;td>dark&lt;/td>
&lt;td>night&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>سرد&lt;/td>
&lt;td>تاریک&lt;/td>
&lt;td>شب&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>my&lt;/td>
&lt;td>Persian&lt;/td>
&lt;td>book&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>من&lt;/td>
&lt;td>فارسی&lt;/td>
&lt;td>کتاب&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>Maryam's&lt;/td>
&lt;td>Russian&lt;/td>
&lt;td>friend&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>مریم&lt;/td>
&lt;td>روسی&lt;/td>
&lt;td>دوست&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table></description></item><item><title>Stable Diffusion Gallery</title><link>https://dustinnewman.net/posts/stable-diffusion-gallery/</link><pubDate>Sat, 24 Sep 2022 18:17:58 -0700</pubDate><guid>https://dustinnewman.net/posts/stable-diffusion-gallery/</guid><description>&lt;p>I have been playing with &lt;a href="https://github.com/CompVis/stable-diffusion">Stable Diffusion&lt;/a> lately, as I am sure many have. I thought it would be worthwhile to publish some of my favorites along with the prompts and seeds for each image. All images have a &amp;ldquo;classifier free guidance (CFG) scale&amp;rdquo; (or simply &amp;ldquo;guidance&amp;rdquo;) value of 7.5; are 512 by 512 pixels; use the k_lms sampler; and use 50 steps. The seeds are marked after the prompt after the -S flag.&lt;/p>
&lt;p>&amp;ldquo;Portrait of a green frog wearing a deep red velvet robe and golden crown, oil painting by Hyacinthe Rigaud, baroque, rich&amp;rdquo; -S3173279521
&lt;img src="./frog_with_crown.png" alt="Frog wearing a crown">&lt;/p>
&lt;p>&amp;ldquo;Impressionist painting of green frog with red eyes by Van Gogh, impressionist&amp;rdquo; -S4232807157
&lt;img src="./van_gogh_frog_close.png" alt="Frog by Van Gogh">&lt;/p>
&lt;p>&amp;ldquo;Impressionist painting of green frog with red eyes in grass meadow, by Van Gogh, impressionist&amp;rdquo; -S2854560348
&lt;img src="./van_gogh_frog_meadow.png" alt="Frog in a meadow by Van Gogh">&lt;/p>
&lt;p>&amp;ldquo;Portrait of a green frog wearing a deep red velvet robe and golden crown, oil painting by Hyacinthe Rigaud, baroque, rich&amp;rdquo; -S1372305360
&lt;img src="./robed_frog.png" alt="Frog in robe">&lt;/p>
&lt;p>&amp;ldquo;a matte painting of an old stone gothic castle on a cliff over the sea at night, creepy, dark, gothic, stormy, masterpiece, artstation&amp;rdquo; -S4153617768
&lt;img src="./creepy_castle.png" alt="Creepy castle">&lt;/p>
&lt;p>&amp;ldquo;Cozy house in the woods, anime, oil painting by Josef Thoma, high resolution, cottagecore, Studio Ghibli inspired, 4k&amp;rdquo; -S2819016467
&lt;img src="./cottage.png" alt="Tree cottage">&lt;/p>
&lt;p>&amp;ldquo;The sun and the moon, roman mosaic&amp;rdquo; -S3992813662
&lt;img src="./sun_mosaic.png" alt="Sun and moon mosaic">&lt;/p>
&lt;p>&amp;ldquo;A white ice palace with tall pillars and an ice throne in the center, by Josef Thoma, matte painting, detailed, 4k&amp;rdquo; -S3712115669
&lt;img src="./ice_pillars.png" alt="Ice pillars">&lt;/p>
&lt;p>&amp;ldquo;overgrown foliage overtaking tall destroyed buildings, biopunk, scenery, professional, award-winning, trending on artstation, detailed, realistic, beautiful, emotional, shiny, golden, picture, antview, close up&amp;rdquo; -S1483373964
&lt;img src="./plants_dystopia.png" alt="Dystopia with plants">&lt;/p>
&lt;p>&amp;ldquo;A beautiful mountain landscape on an ancient scroll, ink brush painting, traditional Chinese, by Ma Yuan&amp;rdquo; -S2983311206
&lt;img src="./ink_brush_painting_mountains.png" alt="Ink brush painting of mountains">&lt;/p>
&lt;p>&amp;ldquo;snow covered mountains in chinese watercolor painting, landscape, masterpiece, ancient&amp;rdquo; -S3991627781
&lt;img src="./chinese_snow.png" alt="Snow covered mountains">&lt;/p>
&lt;p>&amp;ldquo;two people in a snowy mountain village, snow falling from the sky, japanese watercolor painting, color and ink on scroll, by hokusai, landscape painting, masterpiece, ancient&amp;rdquo; -S2964261701
&lt;img src="./japanese_snow.png" alt="Snowy mountain village">&lt;/p>
&lt;p>&amp;ldquo;large persian mosque in the middle of waterfall in chinese watercolor painting, oil painting, masterpiece, aesthetic&amp;rdquo; -S392247870
&lt;img src="./persian_waterfall.png" alt="Waterfall over stones">&lt;/p></description></item><item><title>Cascading Style S-Expressions</title><link>https://dustinnewman.net/posts/lisp-css/</link><pubDate>Sun, 03 Apr 2022 19:44:12 -0700</pubDate><guid>https://dustinnewman.net/posts/lisp-css/</guid><description>&lt;p>Since I first learned it, Lisp has fascinated me. Not enough to seriously use it beyond projects for college, mind you, but enough where - years later - I’m working on something completely random and the thought crosses my mind “It would be fun to implement this in Lisp,” especially using + as a function, same as any other, in full prefix notation, something even the noble and esteemed Haskell couldn’t seem to commit to. Beyond the simple grammar and elegance, there is something about Lisp which feels fundamental to computation itself, likely the similarity to lambda calculus, which actually &lt;em>is&lt;/em> fundamental to computation itself. Sadly, Lisp is rarely used much of anywhere nowadays except as a novelty or pet project. This is strange, considering that Brendan Eich was inspired by Scheme while designing JavaScript. You would think there would be a more direct influence.&lt;/p>
&lt;p>Fortunately for us, it doesn’t have to be that way. I have long thought of writing CSS is a Lisp-style syntax. I’m not sure why exactly. Something about it just &lt;em>feels&lt;/em> right. Simple. For maximum confusion, I have decided to name this &lt;strong>Cascading Style S-Expressions&lt;/strong>: CSS for short.&lt;/p>
&lt;p>Now, I’m not gonna claim that we can bring Lisp to the web. Lisp’s acolytes are a devout and proud people, who would scoff at the claim that CSS properties and markup even come close to represent the power and beauty of Lisp. And this is correct on some level. CSS is a language for configuration, not computation. There are no functions, no inputs or outputs, no arithmetic, none of that. Just a bunch of key-value pairs.&lt;/p>
&lt;p>That said, I’m gonna do it anyways because, like I said, it’s fun. There are some parts of Lisp which fit nicely with CSS. The nesting of S-expressions is a cleaner way to combine selectors; the extremely simple syntax (the only special characters are parentheses) eschews semicolons, colons, and braces; and honestly something about CSS has just always felt Lisp-y to me. But mostly this is just for fun and an itch being scratched. The quintessential example, what every CSS tutorial starts with, is setting the background-color of the body element.&lt;/p>
&lt;pre>&lt;code>(body color red)
&lt;/code>&lt;/pre>
&lt;p>Here the first atom is the selector: the &lt;code>body&lt;/code> element. The next two atoms are actually a pair: the property (color) and its value (red). Together these make up a CSS rule which is just setting one property to some value. This is equivalent to the CSS configuration:&lt;/p>
&lt;pre>&lt;code>body {
color: red;
}
&lt;/code>&lt;/pre>
&lt;p>Can you feel the aesthetic purity already? I sure can. Multiple rules can be chained together by just repeating these pairs.&lt;/p>
&lt;pre>&lt;code>(body color red font-size 14px)
&lt;/code>&lt;/pre>
&lt;p>I’m gonna assume you already know what this would be equivalent too, so I’m not gonna write it out anymore. The real star of the show though, is nested selectors. Compared to CSS where you have no way to nest without writing an entirely new rule set, CSS (Lisp-style) allows you to specify rules for the current selector, and then nest any children in that same rule set. For example, a common use case when styling a navigation bar that uses an unordered list behind the scenes is to get rid of the styling for both the list and the links within the nav bar. In regular CSS, this is two separate rule sets (one for &lt;code>ul&lt;/code> and one for &lt;code>ul li a&lt;/code>), but in our CSS, it’s just one straight line.&lt;/p>
&lt;pre>&lt;code>(ul list-style none (li (a text-decoration none)))
&lt;/code>&lt;/pre>
&lt;p>Allowing the children to be specified as sub-S-expressions is immensely satisfying to me, as I find it better clarifies the relationship between the selectors. Of course, we can also have CSS properties that are more than one word, or contain spaces, the most common being the margin shorthand taking up to four parameters of the border shorthand taking three. For this, I overload the parentheses to create lists. In proper Lisp notation, these would start with a single quote.&lt;/p>
&lt;pre>&lt;code>(body margin (0px 8px 0px 8px) border (1px solid black))
&lt;/code>&lt;/pre>
&lt;p>This is actually not ambiguous to the parser because all rules come in pairs of two: property and value. The nested S-expressions will then be those that don’t follow a property. And what about if you have two S-expressions right next to each other? How do we tell them apart from a rule? Simple: properties cannot contain spaces and thus cannot be listed in parentheses. Therefore, in this case we would have two S-expressions and not a rule.&lt;/p>
&lt;p>If you would like to try this out for yourself, the code is &lt;a href="https://github.com/dustinnewman/cascading-style-s-expressions">open-source&lt;/a> but who wants to go through all the work of pulling and compiling my parser? For that reason, there is also an &lt;a href="https://dustinnewman.net/cascading-style-s-expressions/">online demo&lt;/a> I put together with my first time using WASM. The page is pre-populated with the stylings of that page and you can dynamically edit the CSS to see your Lisp applied. I might end up using this on my own site, the very one you’re reading right now, but time will tell if I have the patience to integrate all of this into Hugo or not.&lt;/p></description></item><item><title>How to use CSS with native dark mode</title><link>https://dustinnewman.net/posts/dark-mode-css/</link><pubDate>Mon, 16 Dec 2019 12:00:00 -0700</pubDate><guid>https://dustinnewman.net/posts/dark-mode-css/</guid><description>&lt;p>With iOS 13, I have been enjoying not just the beautiful new dark mode, but the automatic transition after sunset. It&amp;rsquo;s easier on my eyes and keeps me conscious of using technology too much before bed. That said, the native dark mode is only for native apps. Or is it?&lt;/p>
&lt;p>I thought it would be nice if there were CSS selectors capable of targeting users&amp;rsquo; native preferences on the matter and luckily Apple did not disappoint. In &lt;a href="https://webkit.org/blog/8840/dark-mode-support-in-webkit/">this tutorial post&lt;/a> from the WebKit blog, they introduce the &lt;code>color-scheme&lt;/code> CSS property, which supports both &lt;code>light&lt;/code> and &lt;code>dark&lt;/code> values. I was drawn to this solution over the DIY option (which usually involves some sort of moon icon) because it offers:&lt;/p>
&lt;ol>
&lt;li>Less UI complexity&lt;/li>
&lt;li>More seamless integration with the user&amp;rsquo;s system&lt;/li>
&lt;li>No JavaScript logic required&lt;/li>
&lt;/ol>
&lt;p>All wins in my book, so let&amp;rsquo;s get started! (For this blog, I use SCSS, but I only use the SCSS variables for media queries and the rest of this tutorial uses regular CSS variables.)&lt;/p>
&lt;p>Add this snippet to your top-most styling file (for me, it was my &lt;code>main.scss&lt;/code>):&lt;/p>
&lt;pre>&lt;code>:root {
color-scheme: light dark;
}
&lt;/code>&lt;/pre>
&lt;p>This tells the browser that your site supports both &lt;code>light&lt;/code> and &lt;code>dark&lt;/code> themes. By itself, however, it&amp;rsquo;s not super useful, so let&amp;rsquo;s define some variables that we can switch depending on the theme.&lt;/p>
&lt;pre>&lt;code>:root {
color-scheme: light dark;
--bg-color: #fcfcff;
--text-color: #000000;
}
&lt;/code>&lt;/pre>
&lt;p>Here, we use an off-white as the background color and pure black as the text color. I strongly recommend using functional names rather than descriptive (i.e. &lt;code>bg-color&lt;/code> instead of &lt;code>off-white&lt;/code>) because it allows us to use the same variable declarations with only one media query, rather than using a media query each time we want to use either &lt;code>off-white&lt;/code> or the dark-theme counterpart.&lt;/p>
&lt;p>Now the magic!&lt;/p>
&lt;pre>&lt;code>@media (prefers-color-scheme: dark) {
:root {
--bg-color: #121212;
--text-color: #fcfcfc;
}
}
&lt;/code>&lt;/pre>
&lt;p>With one media query, we re-define our variables so that the &lt;em>text&lt;/em> is now off-white and the background is off-black. To apply this, let&amp;rsquo;s use our main &lt;code>body&lt;/code> element as an example.&lt;/p>
&lt;pre>&lt;code>body {
background-color: var(--bg-color);
color: var(--text-color);
}
&lt;/code>&lt;/pre>
&lt;p>Now our &lt;code>body&lt;/code> will use the &lt;code>bg-color&lt;/code> variable which, if the user prefers dark mode, will be an off-black! Nice! I hope this mini-tutorial was helpful and that you see the advantages of this way over rolling your own moon icon; although I&amp;rsquo;ll admit that might be a bit more fun.&lt;/p></description></item></channel></rss>