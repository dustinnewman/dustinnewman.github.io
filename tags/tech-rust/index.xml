<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech, Rust on Dustin Newman</title><link>https://dustinnewman.net/tags/tech-rust/</link><description>Recent content in Tech, Rust on Dustin Newman</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 04 Nov 2023 16:36:26 -0700</lastBuildDate><atom:link href="https://dustinnewman.net/tags/tech-rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Trait Coherence</title><link>https://dustinnewman.net/posts/rust-trait-coherence/</link><pubDate>Sat, 04 Nov 2023 16:36:26 -0700</pubDate><guid>https://dustinnewman.net/posts/rust-trait-coherence/</guid><description>&lt;h2 id="the-background">The Background&lt;/h2>
&lt;p>I defined a struct in a Rust project.&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Content
&lt;/code>&lt;/pre>
&lt;p>I then wanted an easy way to convert from different, other types into &lt;code>Content&lt;/code>, ideally staying within the Rust type system. My motivating example will be that you want to go from a file path to &lt;code>Content&lt;/code>. Since I am a good, active Rust user, I know that I don&amp;rsquo;t want to unnecessarily restrict my conversion function to only the concrete type &lt;code>Path&lt;/code> because the same logic applies to all sorts of &lt;code>Path&lt;/code>-like types e.g. &lt;code>PathBuf&lt;/code>, &lt;code>Components&lt;/code>, &lt;code>OsStr&lt;/code>, and even &lt;code>String&lt;/code>. So I implemented this trait generically.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P&amp;gt; TryFrom&amp;lt;P&amp;gt; for Content where P: AsRef&amp;lt;Path&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>The compiler threw an error message. This in itself is not too surprising: compiler errors are the bread and butter of Rust programming. But this particular compiler error threw me off guard.&lt;/p>
&lt;pre>&lt;code class="language-rust">conflicting implementation in crate `core`:
- impl&amp;lt;T, U&amp;gt; TryFrom&amp;lt;U&amp;gt; for T
where U: Into&amp;lt;T&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>This came as a bit of a shock to me because, well, I had just defined this struct &lt;code>Content&lt;/code>. How could Rust &lt;code>core&lt;/code> already have an implementation for it? To understand, we have to unpack what the generics in this type signature are really conveying. This type signature says that we have an implementation of &lt;code>TryFrom&lt;/code> &lt;em>from&lt;/em> any type &lt;code>&amp;lt;U&amp;gt;&lt;/code> &lt;em>for&lt;/em> any type &lt;code>&amp;lt;T&amp;gt;&lt;/code> if and only if &lt;code>&amp;lt;U&amp;gt;&lt;/code> already implements &lt;code>Into&amp;lt;T&amp;gt;&lt;/code>. Ok, when you put it like that, this actually seems quite reasonable. If we already have the logic to go from &lt;code>&amp;lt;U&amp;gt;&lt;/code> to &lt;code>&amp;lt;T&amp;gt;&lt;/code> infallibly, then surely we can represent this as a &amp;ldquo;fallible&amp;rdquo; operation, which simply returns &lt;code>Ok&lt;/code> all the time. And, in fact, when you look at the &lt;a href="https://github.com/rust-lang/rust/blob/f5ca57e153afaed818f8be88abf5ce46715c0f9a/library/core/src/convert/mod.rs#L800">Rust core source code&lt;/a>, this is exactly what it does.&lt;/p>
&lt;pre>&lt;code class="language-rust">// Infallible conversions are semantically equivalent to fallible conversions
// with an uninhabited error type.
#[stable(feature = &amp;quot;try_from&amp;quot;, since = &amp;quot;1.34.0&amp;quot;)]
impl&amp;lt;T, U&amp;gt; TryFrom&amp;lt;U&amp;gt; for T
where
U: Into&amp;lt;T&amp;gt;,
{
type Error = Infallible;
#[inline]
fn try_from(value: U) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
Ok(U::into(value))
}
}
&lt;/code>&lt;/pre>
&lt;p>Put this way, this seems not just reasonable but obvious. Of course, this makes sense. The issue I still didn&amp;rsquo;t understand though was that, sure, for any type &lt;code>&amp;lt;U&amp;gt;&lt;/code> if &lt;code>&amp;lt;U&amp;gt;&lt;/code> implements &lt;code>Into&amp;lt;T&amp;gt;&lt;/code> you can use this logical, &amp;ldquo;blanket&amp;rdquo; implementation to kind of vacuously implement &lt;code>TryFrom&amp;lt;U&amp;gt; for T&lt;/code>, &lt;em>but&lt;/em> my issue was that &lt;em>my&lt;/em> &lt;code>&amp;lt;U&amp;gt;&lt;/code> (&lt;code>P: AsRef&amp;lt;Path&amp;gt;&lt;/code>) &lt;strong>doesn&amp;rsquo;t&lt;/strong> implement &lt;code>Into&amp;lt;Content&amp;gt;&lt;/code>. So, why is Rust having an issue with this? And to answer it, we have to go into Rust &lt;strong>trait coherence&lt;/strong>.&lt;/p>
&lt;h2 id="trait-coherence">Trait Coherence&lt;/h2>
&lt;p>Trait coherence is &amp;ldquo;&lt;a href="https://github.com/Ixrec/rust-orphan-rules/blob/4b2ccb102bd7c715c4dc2ec4bdeaa96c6662093c/README.md?plain=1#L9">the property that there is at most one implementation of a trait for any given type&lt;/a>.&amp;rdquo; So, for example, you cannot have:&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Content;
impl Eq for Content
impl Eq for Content
&lt;/code>&lt;/pre>
&lt;p>Once again, when presented like this, this seems reasonable. Despite my confusion, I have to agree that the Rust compiler is making a sane assumption here. The issue, however, quickly becomes more complicated once you allow generics and crates (i.e. third-party code and dependencies). There are two often cited rules to help the Rust compiler enforce trait coherence.&lt;/p>
&lt;ol>
&lt;li>The Orphan Rule: Either the trait or the type for which you are implementing the trait must be local to your crate&lt;/li>
&lt;li>The Overlapping Rule: For any two types A and B implementing a trait T, A must be different from B&lt;/li>
&lt;/ol>
&lt;p>The orphan rule seems much more controversial and discussed online, but I believe my issue actually stems from the overlapping rule. Now, previously I gave an obviously wrong example to motivate why the Rust compiler even has a concept of trait coherence. But to motivate the overlapping rule, let&amp;rsquo;s give a &lt;a href="https://github.com/kennytm/rfcs/blob/a956323627bbc245dd3fe657f1dbc67060e77167/text/0000-negative-bounds.md">more realistic example&lt;/a> in order to steel-man the motivation. Let&amp;rsquo;s say that we have a trait to get the average of two numbers.&lt;/p>
&lt;pre>&lt;code class="language-rust">trait Int {}
trait Float {}
trait Average {
fn average(self, other: Self) -&amp;gt; Self;
}
&lt;/code>&lt;/pre>
&lt;p>We can implement this for &lt;code>Int&lt;/code> types:&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;T: Int&amp;gt; Average for T {
fn average(self, other: Self) -&amp;gt; Self {
if self &amp;gt;= other {
other + (self - other) / 2
} else {
self + (other - self) / 2
}
}
}
&lt;/code>&lt;/pre>
&lt;p>And then for &lt;code>Float&lt;/code> types:&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;T: Float&amp;gt; Average for T {
fn average(self, other: Self) -&amp;gt; Self {
self * 0.5 + other * 0.5
}
}
&lt;/code>&lt;/pre>
&lt;p>Uh-oh! Compiler error. The same as before. &lt;code>conflicting implementations of trait Average&lt;/code>. But&amp;hellip; why? We don&amp;rsquo;t really have two &lt;em>conflicting&lt;/em> implementations, as we have &lt;em>two&lt;/em> implementations. It seems as though Rust is unnecessarily strict here since there is no issue yet. Well, you see, I actually sort of underplayed the overlapping rule earlier. It really should be&lt;/p>
&lt;ol start="2">
&lt;li>The Overlapping Rule: For any two types A and B implementing a trait T, A must be &lt;strong>provably&lt;/strong> different from B &lt;strong>in every possible program&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>This is called &lt;a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">&amp;ldquo;negative reasoning&amp;rdquo;&lt;/a>. It is essentially the difference between saying &amp;ldquo;there does not exist any type which implements a trait twice &lt;em>currently&lt;/em>&amp;rdquo; and &amp;ldquo;there will &lt;em>never&lt;/em> exist any type which implements a trait twice.&amp;rdquo; Hopefully now it is more clear what the actual issue is. There is nothing specifically &lt;strong>stopping&lt;/strong> a type from implementing &lt;strong>both&lt;/strong> &lt;code>Int&lt;/code> and &lt;code>Float&lt;/code>. In the absence of this guarantee, Rust errs on the side of caution. And to Rust&amp;rsquo;s credit, this makes sense. Just look at the following, nothing seems wrong.&lt;/p>
&lt;pre>&lt;code class="language-rust">struct Real
// Is this error?
impl Int for Real
// Or this?
impl Float for Real
&lt;/code>&lt;/pre>
&lt;p>If the compiler instead decided to follow the approach I preferred (don&amp;rsquo;t throw an error until a conflict actually exists), it would make implementating a trait an error. Not just an error, but a rather arbitrary error as well. In the example above, which implementation would you consider the &amp;ldquo;bad&amp;rdquo; one? There is no deterministic answer. This is not only unexpected, but would have breaking downstream consequences: a conflict may exist within other people&amp;rsquo;s crates because of a trait conflict that does &lt;strong>not&lt;/strong> exist on your system, but &lt;strong>does&lt;/strong> exist on theirs. This would be a huge disaster for the Rust ecosystem of crates, not to mention seriously hinder Rust&amp;rsquo;s changes of mainstream adoption. Looking at it from this perspective, it actually becomes clear why the Rust compiler decides to just play it safe and stop the problem at the root: a trait definition which could, theoretically, introduce an implementation conflict. This keeps the wider Rust ecosystem safe until a robust &amp;ldquo;fix&amp;rdquo;/solution is developed.&lt;/p>
&lt;p>But back to my original issue. You might recall that, unlike the previous example, there &lt;em>was no&lt;/em> more specific, conflicting example. I just wanted to implement&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P&amp;gt; TryFrom&amp;lt;P&amp;gt; for Content where P: AsRef&amp;lt;Path&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>It is not so much that there exists &amp;ldquo;two implementations&amp;rdquo; for &lt;code>TryFrom for Content&lt;/code>. It is moreso that currently Rust cannot guarantee that there will never be a type which satisfies two implementations. For example, if someone were to implement &lt;code>TryFrom&amp;lt;String&amp;gt;&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl TryFrom&amp;lt;String&amp;gt; for Content
&lt;/code>&lt;/pre>
&lt;p>This would introduce two valid implementations: one for the generic type &lt;code>P: AsRef&amp;lt;Path&amp;gt;&lt;/code> (which &lt;code>String&lt;/code> satisfies) and another for the specific type &lt;code>String&lt;/code>. Similarly, you could imagine we have a trait to calculate the last modified time of a file path.&lt;/p>
&lt;pre>&lt;code class="language-rust">trait LastModified {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime;
}
&lt;/code>&lt;/pre>
&lt;p>For all regular files, this is simple. Just take the modified time (&lt;code>mtime&lt;/code>).&lt;/p>
&lt;pre>&lt;code class="language-rust">impl&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt; LastModified for P {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime {
fs::metadata(self.as_ref())
.and_then(|metadata| metadata.modified())
.unwrap_or(SystemTime::UNIX_EPOCH)
}
}
&lt;/code>&lt;/pre>
&lt;p>But for directories, the &lt;code>mtime&lt;/code> might not be exactly what we want. It most likely will be the last time a file or subdirectory was added or removed from the directory, rather than the last time a file or subdirectory was actually &lt;em>modified&lt;/em>. To fix this, we would have to make a special implementation just for directories.&lt;/p>
&lt;pre>&lt;code class="language-rust">impl LastModified for ReadDir {
fn last_modified(&amp;amp;self) -&amp;gt; std::time::SystemTime {
self.filter_map(Result::ok)
.map(|entry| entry.path())
.filter_map(|path| fs::metadata(&amp;amp;path).ok())
.filter_map(|metadata| metadata.modified().ok())
.max()
.unwrap_or(SystemTime::UNIX_EPOCH)
}
}
&lt;/code>&lt;/pre>
&lt;p>So which one to choose? Currently, there is no way, and doing so would require a feature called &amp;ldquo;specialization&amp;rdquo;.&lt;/p>
&lt;p>There are a few options here:&lt;/p>
&lt;ol>
&lt;li>Extend Rust to supportive &amp;ldquo;negative&amp;rdquo; trait bounds (i.e. &lt;code>P: AsRef&amp;lt;Path&amp;gt; &amp;amp;! ContentNode: TryFrom&amp;lt;P&amp;gt;&lt;/code>) to allow the compiler to guarantee one implementation per type&lt;/li>
&lt;li>Allow multiple implementations per type and design a mechanism for deciding between them (&amp;ldquo;specialization&amp;rdquo;)&lt;/li>
&lt;li>Allow users to specify a crate locality condition that this crate will never be used by any other crate and thus we can bypass this condition just between us&lt;/li>
&lt;li>Just use &lt;code>PathBuf&lt;/code> here instead of generics&lt;/li>
&lt;/ol>
&lt;p>For now, I&amp;rsquo;m sticking with number four.&lt;/p></description></item><item><title>Farsi Ezafe Trick for L1 English Speakers</title><link>https://dustinnewman.net/posts/farsi-ezafe-trick/</link><pubDate>Sat, 28 Oct 2023 12:14:06 -0700</pubDate><guid>https://dustinnewman.net/posts/farsi-ezafe-trick/</guid><description>&lt;p>I recently came across a neat trick in &lt;em>Modern Persian&lt;/em> by Narguess Farzad (2004) for an intuition on the order of adjectives and possessives in Farsi (Iranian Persian). As an L1 English speaker, it can be difficult to get an intuition for the adjective order (postpositional) and how that works with the possessives in Farsi (also postpositional).&lt;/p>
&lt;p>You simply write the English phrase as usual: left to right. Then underneath you write the Farsi translation: right to left. Because adjectives and possessives are postpositional, but Farsi is also written right to left, the two &amp;ldquo;reverse&amp;rdquo; and provide a simple way to get the correct word order in Farsi. Farzad provides the simple example:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>blue&lt;/td>
&lt;td>pencil&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>آبی&lt;/td>
&lt;td>مداد&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>Because possessive adjectives follow attributive adjectives, this extends to genitive constructions as well:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>my&lt;/td>
&lt;td>brother's&lt;/td>
&lt;td>hand&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>من&lt;/td>
&lt;td>برادر&lt;/td>
&lt;td>دست&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;p>And to multiple adjectives:&lt;/p>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>cold&lt;/td>
&lt;td>dark&lt;/td>
&lt;td>night&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>سرد&lt;/td>
&lt;td>تاریک&lt;/td>
&lt;td>شب&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>my&lt;/td>
&lt;td>Persian&lt;/td>
&lt;td>book&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>من&lt;/td>
&lt;td>فارسی&lt;/td>
&lt;td>کتاب&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table>
&lt;table>
&lt;tr>
&lt;td>→&lt;/td>
&lt;td>Maryam's&lt;/td>
&lt;td>Russian&lt;/td>
&lt;td>friend&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>مریم&lt;/td>
&lt;td>روسی&lt;/td>
&lt;td>دوست&lt;/td>
&lt;td>←&lt;/td>
&lt;/tr>
&lt;/table></description></item><item><title>Stable Diffusion Gallery</title><link>https://dustinnewman.net/posts/stable-diffusion-gallery/</link><pubDate>Sat, 24 Sep 2022 18:17:58 -0700</pubDate><guid>https://dustinnewman.net/posts/stable-diffusion-gallery/</guid><description>&lt;p>I have been playing with &lt;a href="https://github.com/CompVis/stable-diffusion">Stable Diffusion&lt;/a> lately, as I am sure many have. I thought it would be worthwhile to publish some of my favorites along with the prompts and seeds for each image. All images have a &amp;ldquo;classifier free guidance (CFG) scale&amp;rdquo; (or simply &amp;ldquo;guidance&amp;rdquo;) value of 7.5; are 512 by 512 pixels; use the k_lms sampler; and use 50 steps. The seeds are marked after the prompt after the -S flag.&lt;/p>
&lt;figure>&lt;img src="./frog_with_crown.png"
alt="Frog wearing a crown">&lt;figcaption>
&lt;p>&lt;em>Portrait of a green frog wearing a deep red velvet robe and golden crown, oil painting by Hyacinthe Rigaud, baroque, rich&lt;/em> -S3173279521&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./van_gogh_frog_close.png"
alt="Frog by Van Gogh">&lt;figcaption>
&lt;p>&lt;em>Impressionist painting of green frog with red eyes by Van Gogh, impressionist&lt;/em> -S4232807157&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./van_gogh_frog_meadow.png"
alt="Frog in a meadow by Van Gogh">&lt;figcaption>
&lt;p>&lt;em>Impressionist painting of green frog with red eyes in grass meadow, by Van Gogh, impressionist&lt;/em> -S2854560348&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./robed_frog.png"
alt="Frog in robe">&lt;figcaption>
&lt;p>&lt;em>Portrait of a green frog wearing a deep red velvet robe and golden crown, oil painting by Hyacinthe Rigaud, baroque, rich&lt;/em> -S1372305360&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./creepy_castle.png"
alt="Creepy castle">&lt;figcaption>
&lt;p>&lt;em>a matte painting of an old stone gothic castle on a cliff over the sea at night, creepy, dark, gothic, stormy, masterpiece, artstation&lt;/em> -S4153617768&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./cottage.png"
alt="Tree cottage">&lt;figcaption>
&lt;p>&lt;em>Cozy house in the woods, anime, oil painting by Josef Thoma, high resolution, cottagecore, Studio Ghibli inspired, 4k&lt;/em> -S2819016467&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./sun_mosaic.png"
alt="Sun and moon mosaic">&lt;figcaption>
&lt;p>&lt;em>The sun and the moon, roman mosaic&lt;/em> -S3992813662&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./ice_pillars.png"
alt="Ice pillars">&lt;figcaption>
&lt;p>&lt;em>A white ice palace with tall pillars and an ice throne in the center, by Josef Thoma, matte painting, detailed, 4k&lt;/em> -S3712115669&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./plants_dystopia.png"
alt="Dystopia with plants">&lt;figcaption>
&lt;p>&lt;em>overgrown foliage overtaking tall destroyed buildings, biopunk, scenery, professional, award-winning, trending on artstation, detailed, realistic, beautiful, emotional, shiny, golden, picture, antview, close up&lt;/em> -S1483373964&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./ink_brush_painting_mountains.png"
alt="Ink brush painting of mountains">&lt;figcaption>
&lt;p>&lt;em>A beautiful mountain landscape on an ancient scroll, ink brush painting, traditional Chinese, by Ma Yuan&lt;/em> -S2983311206&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./chinese_snow.png"
alt="Snow covered mountains">&lt;figcaption>
&lt;p>&lt;em>snow covered mountains in chinese watercolor painting, landscape, masterpiece, ancient&lt;/em> -S3991627781&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./japanese_snow.png"
alt="Snowy mountain village">&lt;figcaption>
&lt;p>&lt;em>two people in a snowy mountain village, snow falling from the sky, japanese watercolor painting, color and ink on scroll, by hokusai, landscape painting, masterpiece, ancient&lt;/em> -S2964261701&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="./persian_waterfall.png"
alt="Waterfall over stones">&lt;figcaption>
&lt;p>&lt;em>large persian mosque in the middle of waterfall in chinese watercolor painting, oil painting, masterpiece, aesthetic&lt;/em> -S392247870&lt;/p>
&lt;/figcaption>
&lt;/figure></description></item><item><title>Cascading Style S-Expressions</title><link>https://dustinnewman.net/posts/lisp-css/</link><pubDate>Sun, 03 Apr 2022 19:44:12 -0700</pubDate><guid>https://dustinnewman.net/posts/lisp-css/</guid><description>&lt;p>Since I first learned it, Lisp has fascinated me. Not enough to seriously use it beyond projects for college, mind you, but enough where - years later - I’m working on something completely random and the thought crosses my mind “It would be fun to implement this in Lisp,” especially using + as a function, same as any other, in full prefix notation, something even the noble and esteemed Haskell couldn’t seem to commit to. Beyond the simple grammar and elegance, there is something about Lisp which feels fundamental to computation itself, likely the similarity to lambda calculus, which actually &lt;em>is&lt;/em> fundamental to computation itself. Sadly, Lisp is rarely used much of anywhere nowadays except as a novelty or pet project. This is strange, considering that Brendan Eich was inspired by Scheme while designing JavaScript. You would think there would be a more direct influence.&lt;/p>
&lt;p>Fortunately for us, it doesn’t have to be that way. I have long thought of writing CSS is a Lisp-style syntax. I’m not sure why exactly. Something about it just &lt;em>feels&lt;/em> right. Simple. For maximum confusion, I have decided to name this &lt;strong>Cascading Style S-Expressions&lt;/strong>: CSS for short.&lt;/p>
&lt;p>Now, I’m not gonna claim that we can bring Lisp to the web. Lisp’s acolytes are a devout and proud people, who would scoff at the claim that CSS properties and markup even come close to represent the power and beauty of Lisp. And this is correct on some level. CSS is a language for configuration, not computation. There are no functions, no inputs or outputs, no arithmetic, none of that. Just a bunch of key-value pairs.&lt;/p>
&lt;p>That said, I’m gonna do it anyways because, like I said, it’s fun. There are some parts of Lisp which fit nicely with CSS. The nesting of S-expressions is a cleaner way to combine selectors; the extremely simple syntax (the only special characters are parentheses) eschews semicolons, colons, and braces; and honestly something about CSS has just always felt Lisp-y to me. But mostly this is just for fun and an itch being scratched. The quintessential example, what every CSS tutorial starts with, is setting the background-color of the body element.&lt;/p>
&lt;pre>&lt;code>(body color red)
&lt;/code>&lt;/pre>
&lt;p>Here the first atom is the selector: the &lt;code>body&lt;/code> element. The next two atoms are actually a pair: the property (color) and its value (red). Together these make up a CSS rule which is just setting one property to some value. This is equivalent to the CSS configuration:&lt;/p>
&lt;pre>&lt;code>body {
color: red;
}
&lt;/code>&lt;/pre>
&lt;p>Can you feel the aesthetic purity already? I sure can. Multiple rules can be chained together by just repeating these pairs.&lt;/p>
&lt;pre>&lt;code>(body color red font-size 14px)
&lt;/code>&lt;/pre>
&lt;p>I’m gonna assume you already know what this would be equivalent too, so I’m not gonna write it out anymore. The real star of the show though, is nested selectors. Compared to CSS where you have no way to nest without writing an entirely new rule set, CSS (Lisp-style) allows you to specify rules for the current selector, and then nest any children in that same rule set. For example, a common use case when styling a navigation bar that uses an unordered list behind the scenes is to get rid of the styling for both the list and the links within the nav bar. In regular CSS, this is two separate rule sets (one for &lt;code>ul&lt;/code> and one for &lt;code>ul li a&lt;/code>), but in our CSS, it’s just one straight line.&lt;/p>
&lt;pre>&lt;code>(ul list-style none (li (a text-decoration none)))
&lt;/code>&lt;/pre>
&lt;p>Allowing the children to be specified as sub-S-expressions is immensely satisfying to me, as I find it better clarifies the relationship between the selectors. Of course, we can also have CSS properties that are more than one word, or contain spaces, the most common being the margin shorthand taking up to four parameters of the border shorthand taking three. For this, I overload the parentheses to create lists. In proper Lisp notation, these would start with a single quote.&lt;/p>
&lt;pre>&lt;code>(body margin (0px 8px 0px 8px) border (1px solid black))
&lt;/code>&lt;/pre>
&lt;p>This is actually not ambiguous to the parser because all rules come in pairs of two: property and value. The nested S-expressions will then be those that don’t follow a property. And what about if you have two S-expressions right next to each other? How do we tell them apart from a rule? Simple: properties cannot contain spaces and thus cannot be listed in parentheses. Therefore, in this case we would have two S-expressions and not a rule.&lt;/p>
&lt;p>If you would like to try this out for yourself, the code is &lt;a href="https://github.com/dustinnewman/cascading-style-s-expressions">open-source&lt;/a> but who wants to go through all the work of pulling and compiling my parser? For that reason, there is also an &lt;a href="https://dustinnewman.net/cascading-style-s-expressions/">online demo&lt;/a> I put together with my first time using WASM. The page is pre-populated with the stylings of that page and you can dynamically edit the CSS to see your Lisp applied. I might end up using this on my own site, the very one you’re reading right now, but time will tell if I have the patience to integrate all of this into Hugo or not.&lt;/p></description></item><item><title>How to use CSS with native dark mode</title><link>https://dustinnewman.net/posts/dark-mode-css/</link><pubDate>Mon, 16 Dec 2019 12:00:00 -0700</pubDate><guid>https://dustinnewman.net/posts/dark-mode-css/</guid><description>&lt;p>With iOS 13, I have been enjoying not just the beautiful new dark mode, but the automatic transition after sunset. It&amp;rsquo;s easier on my eyes and keeps me conscious of using technology too much before bed. That said, the native dark mode is only for native apps. Or is it?&lt;/p>
&lt;p>I thought it would be nice if there were CSS selectors capable of targeting users&amp;rsquo; native preferences on the matter and luckily Apple did not disappoint. In &lt;a href="https://webkit.org/blog/8840/dark-mode-support-in-webkit/">this tutorial post&lt;/a> from the WebKit blog, they introduce the &lt;code>color-scheme&lt;/code> CSS property, which supports both &lt;code>light&lt;/code> and &lt;code>dark&lt;/code> values. I was drawn to this solution over the DIY option (which usually involves some sort of moon icon) because it offers:&lt;/p>
&lt;ol>
&lt;li>Less UI complexity&lt;/li>
&lt;li>More seamless integration with the user&amp;rsquo;s system&lt;/li>
&lt;li>No JavaScript logic required&lt;/li>
&lt;/ol>
&lt;p>All wins in my book, so let&amp;rsquo;s get started! (For this blog, I use SCSS, but I only use the SCSS variables for media queries and the rest of this tutorial uses regular CSS variables.)&lt;/p>
&lt;p>Add this snippet to your top-most styling file (for me, it was my &lt;code>main.scss&lt;/code>):&lt;/p>
&lt;pre>&lt;code>:root {
color-scheme: light dark;
}
&lt;/code>&lt;/pre>
&lt;p>This tells the browser that your site supports both &lt;code>light&lt;/code> and &lt;code>dark&lt;/code> themes. By itself, however, it&amp;rsquo;s not super useful, so let&amp;rsquo;s define some variables that we can switch depending on the theme.&lt;/p>
&lt;pre>&lt;code>:root {
color-scheme: light dark;
--bg-color: #fcfcff;
--text-color: #000000;
}
&lt;/code>&lt;/pre>
&lt;p>Here, we use an off-white as the background color and pure black as the text color. I strongly recommend using functional names rather than descriptive (i.e. &lt;code>bg-color&lt;/code> instead of &lt;code>off-white&lt;/code>) because it allows us to use the same variable declarations with only one media query, rather than using a media query each time we want to use either &lt;code>off-white&lt;/code> or the dark-theme counterpart.&lt;/p>
&lt;p>Now the magic!&lt;/p>
&lt;pre>&lt;code>@media (prefers-color-scheme: dark) {
:root {
--bg-color: #121212;
--text-color: #fcfcfc;
}
}
&lt;/code>&lt;/pre>
&lt;p>With one media query, we re-define our variables so that the &lt;em>text&lt;/em> is now off-white and the background is off-black. To apply this, let&amp;rsquo;s use our main &lt;code>body&lt;/code> element as an example.&lt;/p>
&lt;pre>&lt;code>body {
background-color: var(--bg-color);
color: var(--text-color);
}
&lt;/code>&lt;/pre>
&lt;p>Now our &lt;code>body&lt;/code> will use the &lt;code>bg-color&lt;/code> variable which, if the user prefers dark mode, will be an off-black! Nice! I hope this mini-tutorial was helpful and that you see the advantages of this way over rolling your own moon icon; although I&amp;rsquo;ll admit that might be a bit more fun.&lt;/p></description></item></channel></rss>