<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Dustin Newman's blog"><link rel="shortcut icon" type=image/x-icon href=https://dustinnewman.net/favicon.ico><link rel=stylesheet href=https://dustinnewman.net/css/normalize.css><link rel=stylesheet href=https://dustinnewman.net/css/magick.css><script defer language=javascript type=text/javascript src=https://dustinnewman.net/js/codelines.js></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["$","$"]]}}</script><title>Remove Duplicates 2</title></head><body><main><header><h1><a href=https://dustinnewman.net/>Dustin Newman</a></h1><nav><ul><li><a href=/ title=Posts>Posts</a></li><li><a href=/about/ title=About>About</a></li></ul></nav></header><article><h1>Remove Duplicates 2</h1><p><em>June 17, 2024</em></p><p>I have recently been brushing up on some interview prep with LeetCode. For one of the problems, despite only being a &ldquo;medium&rdquo; difficulty, I came up with an interesting solution that pulled from my experience developing cellular firmware that I would like to share. It is very common when dealing with frequency ranges for radio frequency (RF) bands and that these ranges are organized in tables. It is also common for special rules or regulations to apply when dealing with the &ldquo;edge&rdquo; ranges of these bands. For example, if we have band 1, it might have a low and high edge that has a lower or higher maximum transmissible power.</p><table><thead><tr><th>Band</th><th>Frequency</th><th>Edge?</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>Yes</td></tr><tr><td>1</td><td>11</td><td>No</td></tr><tr><td>1</td><td>12</td><td>No</td></tr><tr><td>1</td><td>13</td><td>Yes</td></tr><tr><td>2</td><td>20</td><td>No</td></tr><tr><td>3</td><td>24</td><td>No</td></tr></tbody></table><p>A common way to identify these edge regions is to compare the current band with the previous and next bands. If both the previous and next bands are the same as the current, then we are in an edge region. Else, we aren&rsquo;t. Then you can add some special handling for the first and last regions in the table, etc.</p><p>Now, the LeetCode problem is to remove duplicates from an array of integers, but allow up to two duplicates for any given value. So if you had the array <code>[1,1,1,2,2,3]</code>, the output would be <code>[1,1,2,2,3]</code>. On the face of it, this has nothing to do with the frequency range concept I just described. However, I have always visualized the edge region filtering as a sort of &ldquo;catching the wave.&rdquo; Basically, if we turn our table into an array of only the band numbers, we can denote the start of the band with a forward slash / and the end of the band with a backwards slash. Non-edge regions will be denoted with a dash -.</p><pre><code> / - - \ / /
[1,1,1,1,2,3]
</code></pre><p>Note the slight difference from the table earlier. Here, when we first see a new band number, we somewhat optimistically label it the &ldquo;rising edge&rdquo; of the band.</p><p>My key insight was realizing that removing the duplicates with an allowance of two actually reduced to &ldquo;catching the wave.&rdquo; We want to take only the rising and falling edges of the frequency bands. This allowed me to apply both my RF knowledge and the corresponding embedded programming knowledge (where every byte counts) to come up with a quite minimal C++ solution.</p><pre><code class=language-cpp>int removeDuplicates(vector&lt;int&gt;&amp; nums) {
    int k = 1;
    for (size_t i = 1; i &lt; nums.size(); i++) {
        if (nums[i] != nums[i - 1] || i == nums.size() - 1 || nums[i] != nums[i + 1]) {
            nums[k++] = nums[i];
        }
    }
    return k;
}
</code></pre><p>where <code>k</code> denotes the length of the de-duplicated array. (Don&rsquo;t judge me for using a signed integer for the return value. LeetCode forced the interface on me.) We initialize it to 1 to reflect the fact that every non-empty array (LeetCode guaranteed the arrays would be non-empty) will contain at least 1 element. We then iterate through the array and &ldquo;catch the waves&rdquo;: if the current element is not equal to the previous or next elements, then we have either the rising or falling edges. And then there is an additional check for the final element of the array which should always be included (either because it is the falling edge of a run or because it is unique).</p></article></main><footer></footer></body></html>