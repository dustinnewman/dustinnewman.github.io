<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Dustin Newman's blog"><link rel="shortcut icon" type=image/x-icon href=https://dustinnewman.net/favicon.ico><link rel=stylesheet href=https://dustinnewman.net/css/normalize.css><link rel=stylesheet href=https://dustinnewman.net/css/magick.css><script defer language=javascript type=text/javascript src=https://dustinnewman.net/js/codelines.js></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["$","$"]]}}</script><title>Journey With GANs</title></head><body><main><header><h1><a href=https://dustinnewman.net/>Dustin Newman</a></h1><nav><ul><li><a href=/ title=Posts>Posts</a></li><li><a href=/about/ title=About>About</a></li></ul></nav></header><article><h1>Journey With GANs</h1><p><em>June 18, 2024</em></p><p>My first foray into generative models begins with generative adversarial models (or <strong>GANs</strong>). Introduced in 2014 by Ian Goodfellow et al. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, GANs quickly gained popularity for their ability to generate high quality, diverse, high-dimensional data samples. As you will soon see, however, the emphasis here is very much on &ldquo;ability to,&rdquo; and not &ldquo;tendency to,&rdquo; for GANs are notoriously sensitive to hyperparameters, often become unstable during training due to their adversarial nature, and are prone to vanishing gradients. Luckily, the generative capability of these models inspired an equally impressive volume of research and experimentation on how to mitigate these challenges and improve the performance of GANs for some truly amazing results.</p><p>For all experiments here (except <a href=#shellgan>ShellGAN</a>), I used the <a href=https://mmlab.ie.cuhk.edu.hk/projects/CelebA.html>CelebA</a> dataset: 200k 178 x 218 pixels images of celebrities. The full dataset is labelled, but I was only interested in unsupervised learning here.</p><h2 id=gan-overview>GAN Overview</h2><p>GANs are composed of two models: the generator model and the discriminator model. The generator <em>generates</em> samples from the underlying distribution of the training data, while the discriminator <em>discriminates</em> between real samples from the training data and fake samples produced by the generator. The basic idea is to train the two models simultaneously, so that both improve together at similar rates. The training is adversarial because the generator&rsquo;s goal is to fool the discriminator with convincing fake samples, while the discriminator&rsquo;s goal is to determine which samples are from the data and which are generated. Ian Goodfellow uses the following analogy:</p><blockquote><p>The generative model can be thought of as analogous to a team of counterfeiters, trying to produce fake currency and use it without detection, while the discriminative model is analogous to the police, trying to detect the counterfeit currency. Competition in this game drives both teams to improve their methods until the counterfeits are indistiguishable from the genuine articles.</p></blockquote><p>Training for the overall GAN is therefore framed as a &ldquo;game&rdquo; between the generator and the discriminator. The generator&rsquo;s objective is to minimize the discriminator&rsquo;s score (by fooling it) and the discriminator&rsquo;s objective is maximize its probability of correctly classifying the real and fake data. Assuming a class label of 1 for real data and 0 for fake data, the value function is</p>$$
\underset{G}{\min}\underset{D}{\max} \mathbb{E}_{x \sim p_{X}}[\log D(x)] + \mathbb{E}_{z \sim p_{Z}}[\log (1 - D(G(z)))]
$$<p>where $p_{X}$ is the probability distribution of the training data and $p_{Z}$ is the probability distribution of the latent space (usually the uniform distribution). Walking through this, the value function is maximal when $D(x) = 1$ (because $\log D(x) = \log 1 = 0$) and $D(G(z)) = 0$ and it is minimal when $D(G(z)) = 1$ (because $\log (1 - D(G(z))) = -\infty$). So you can see the adversarial relationship is reflected here. In terms of training, the basic formulation is</p><pre><code class=language-python>for real_images in data:
    z = get_noise_vector()
    fake_images = generator(z)
    fake_predictions = discriminator(fake_images)
    real_predictions = discriminator(real_images)
    loss_d = BCELoss(fake_predictions, 0) + BCELoss(real_predictions, 1)
    loss_g = BCELoss(fake_predictions, 1)
</code></pre><p>I did not actually implement the original GAN architecture using fully-connected layers from this paper on the CelebA dataset since, by the time of writing this, several iterations of improvements are already standard and produce much better results. However, it is actually quite instructive to use this architecture on simpler datasets to get an intuition for some of the dynamics and results being produced here. I first trained a simple two fully-connected layer GAN using a training set of 10,000 samples from the unit normal distribution (mean 0, standard deviation 1) with a 10,000 dimension noise vector for 10,000 epochs. I want to show the progression of generated data first so you can see what the gist is.</p><video width=100% height=auto loop mute controls playsinline>
<source src=./normgan_distribution_dark.mp4 type=video/mp4></video><p>You can see that the generated data starts off centered at zero and then quickly begins oscillating around the mean, coming back towards the mean and then back around again for a couple thousand epochs. However, then around epoch 3,000 the generator starts matching the training distribution rather accurately. I like this GIF because it really captures the &ldquo;game&rdquo; aspect of GAN training. After around epoch 7,000, the generated data starts doing a little dance and cheer, oscillating slightly around the mean. The generator and discriminator really are playing a game, with one gaining the upper-hand slightly and the other reacting quickly thereafter. Matching up the epochs show above with the loss dynamics is also illuminating.</p><p><img src=normgan_loss_dark.png alt="Loss functions of the generator and discriminator in vanilla GAN"></p><p>Again, the adversarial aspects of the generator and discriminator are reflected in the loss functions, almost looking like a sin-cosine wave pair in the beginning. When the generator starts improving and generating better fakes, the discriminator&rsquo;s loss goes up. It then improves via gradient-descent, reducing its loss until the point where the generator starts improving, and so on until the two reach convergence. Note that convergence in GANs means the generator and discriminator each converge to their own separate loss value, not the same loss value. Correlating from earlier, just around epoch 3,000 was when the generator started performing noticeably better to the human eye, and sure enough, the loss function reflects that, converging right around epoch 3,000. And then when the distribution starts oscillating and &ldquo;cheering&rdquo; around epoch 7,000, you can see the norm of the gradients starts increasing, causing larger updates to the model weights, causing larger oscillations.</p><p>An interesting point to note that underscores GANs&rsquo; instability is that the model actually starts performing <em>worse</em> after reaching a optimum around epoch 6,000. After that, the gradient updates increase and both the generator and discriminator models start having higher highs and lower lows in their loss scores.</p><h2 id=dcgan>DCGAN</h2><p><strong>Training time</strong>: A few hours</p><p>The deep convolutional GAN (<strong>DCGAN</strong>) is where I actually started my experiments. This architecture was first introduced in 2015 <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and the key insight here was to use only convolutional layers and batch normalization, without any fully connected or static pooling layers. The intelligent use of convolutions proposed allows the model to better capture spatial information from the data, which it can use to generate more realistic images. Batch normalization helps to stabilize the generator and discriminator networks by reducing the internal covariate shift: the shift in the distribution of neuron activations during training. I also normalized and center-cropped the dataset as part of pre-processing which helps create more uniform contours in the cost function space and thus leads to faster and more stable convergence. With the exception of the number of feature maps, I used the same hyperparameters recommended by the paper authors.</p><table><thead><tr><th>Hyperparameter</th><th>Value</th></tr></thead><tbody><tr><td>Learning rate $\alpha$</td><td>0.0002</td></tr><tr><td>Batch size</td><td>128</td></tr><tr><td>LeakyReLU slope</td><td>0.2</td></tr><tr><td>Momentum $\beta_{1}$</td><td>0.5</td></tr><tr><td>$Z$ dimension</td><td>100</td></tr><tr><td>Convolutional layers</td><td>4</td></tr><tr><td>Generator feature maps</td><td>100</td></tr><tr><td>Discriminator feature maps</td><td>100</td></tr><tr><td>Image size</td><td>64</td></tr></tbody></table><p>As mentioned above, I used the model architecture described by the paper authors for this.</p><pre><code class=language-python>generator = nn.Sequential(
    # Conv 1
    nn.ConvTranspose2d(z_dim, ngf * 8, 4, 1, 0, bias=False),
    nn.BatchNorm2d(ngf * 8),
    nn.ReLU(inplace = True),
    # Conv 2
    nn.ConvTranspose2d(ngf * 8, ngf * 4, 4, 2, 1, bias=False),
    nn.BatchNorm2d(ngf * 4),
    nn.ReLU(inplace = True),
    # Conv 3
    nn.ConvTranspose2d(ngf * 4, ngf * 2, 4, 2, 1, bias=False),
    nn.BatchNorm2d(ngf * 2),
    nn.ReLU(inplace = True),
    # Conv 4
    nn.ConvTranspose2d(ngf * 2, ngf, 4, 2, 1, bias=False),
    nn.BatchNorm2d(ngf),
    nn.ReLU(inplace = True),
    # Conv 5
    nn.ConvTranspose2d(ngf, IM_CHAN, 4, 2, 1, bias=False),
    nn.Tanh()
)
discriminator = nn.Sequential(
    # Conv 1
    nn.Conv2d(IM_CHAN, ndf, 4, 2, 1),
    nn.BatchNorm2d(ndf),
    nn.LeakyReLU(0.2, inplace=True),
    # Conv 2
    nn.Conv2d(ndf, ndf * 2, 4, 2, 1),
    nn.BatchNorm2d(ndf * 2),
    nn.LeakyReLU(0.2,  inplace=True),
    # Conv 3
    nn.Conv2d(ndf * 2, ndf * 4, 4, 2, 1),
    nn.BatchNorm2d(ndf * 4),
    nn.LeakyReLU(0.2, inplace=True),
    # Conv 4
    nn.Conv2d(ndf * 4, ndf * 8, 4, 2, 1),
    nn.BatchNorm2d(ndf * 8),
    nn.LeakyReLU(0.2, inplace=True),
    # Conv 5
    nn.Conv2d(ndf * 8, 1, 4, 1, 0),
    nn.Sigmoid(),
    nn.Flatten(),
)
</code></pre><p>After training for 50 epochs with a batch size of 128 images per batch, the results were&mldr; not awful.</p><p><img src=dcgan_1.png alt="A grid of 16 blurry vaguely face-looking images"></p><p>But they certainly weren&rsquo;t good either. At best, they were interesting. I could see the generator was learning probably 70-75% of what made a face, but failing to make a convincing final composition. And this is despite the fact that training actually went exactly what you would expect. Since the discriminator has an &ldquo;easier job&rdquo; than the generator, it is common for the discriminator loss to progressively lessen towards 0 as the generator loss converges to some positive number. Indeed, this is exactly what I observed.</p><p><img src=dcgan_loss_1.png alt="A graph showing the discriminator loss converging to zero and the generator loss gradually increasing around three"></p><p>Because the scales for the generator and discriminator loss are often quite different in GANs (with the generator having the higher loss), it is a bit more enlightening to rather look at the normalized losses to see the shape and direction of the loss functions rather than the exact values. You can also definitely see the &ldquo;adversarial&rdquo; aspect more on display here with the inverse correlation in the loss functions.</p><p><img src=dcgan_loss_1_norm.png alt="A graph showing the normalized discriminator loss decreasing and the normalized generator loss increasing"></p><p>This is basically what you expect. The discriminator gets better and better and, as it does, the generator&rsquo;s loss rises. As long as the generator and discriminator learn <em>together</em> at a similar pace, learning overall still occurs. However, if the discriminator becomes too good at determining fakes, it quickly starts scoring a near perfect score and giving the generator little &ldquo;feedback&rdquo;. This is known as the <strong>vanishing gradient</strong> problem. Remember that the discriminator outputs a sigmoid score which is the probability the discriminator is assigning of the image being fake (0) or real (1). So, as the discriminator gets better and better, its probabilities get pushed further and further towards either 0 or 1, resulting in progressively less feedback being passed back to the generator for it to improve.</p><p><img src=sigmoid.png alt="A graph of the sigmoid function with the tails highlighted as vanishing gradients and areas of zero derivative."></p><p>Once the vanishing gradient problem has taken root, no additional epochs will help the generator since further steps of gradient descent will only incrementally push the weights of the discriminator closer to its (local) optimum. And because the generator cannot improve, the discriminator stops learning as well.</p><h3 id=one-layer-deeper>One layer deeper</h3><p><strong>Training time</strong>: A few hours</p><p>After these middling results, I was figuring I was simply not using a large or deep enough architecture. Faces have quite a lot of features to learn and I wanted to see if the results improved if I gave the generator in particular bigger feature maps (convolutional output channels) to better learn spatial information from the data, coupled with bigger image sizes. I made the following changes to my architecture:</p><ul><li>Increase image size from 64 to 128 (more data = better model?)</li><li>Add extra convolutional layer in both generator and discriminator</li><li>Decrease batch size from 128 to 64</li><li>Increase generator feature map count <code>ngf</code> to 160</li><li>Decrease discriminator feature map count <code>ndf</code> to 40</li></ul><p>The training time was similar to above with 50 epochs and the same dataset (just larger). After training, we see an increase in image quality but not in overall fidelity. That is, there are more details but the details are nightmarishly wrong. Unfortunately, there were similar vanishing gradient problems as earlier. This makes sense, as there were no changes to the loss function to help mitigate this. Various methods for this are known, such as Wasserstein GAN with gradient penalty (WGAN-GP). <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p><img src=dcgan_2.png alt="A grid of 16 more detailed but more uncanny faces"></p><h2 id=stylegan2>StyleGAN2</h2><p><strong>Training time</strong>: 14 hours</p><p>For my next step, eager to get SOTA results, I actually skipped past WGAN and wanted to try my hand at the latest and greatest in GANs: StyleGAN2 (which uses WGAN-GP loss). <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><p>For running StyleGAN2, my M1 MacBook Pro simply wouldn&rsquo;t cut it. I needed real GPU power, the least of which for CUDA support to actually run <a href=https://github.com/NVlabs/stylegan2-ada-pytorch>Nvidia&rsquo;s implementation of StyleGAN2</a>. I used the implemention with adaptive instance normalization (<code>AdaIN</code>) for even better results. <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> All GPUs used for this post were rented from <a href=https://vast.ai>Vast.ai</a>. I initially had some trouble since I was using the default image <code>pytorch/pytorch:latest</code> instead of the image specifically with CUDA/NVCC support <code>pytorch/pytorch:2.2.0-cuda12.1-cudnn8-devel</code>. You will notice that both images (at least at the time of writing) use PyTorch <strong>2</strong> where Nvidia&rsquo;s implementation uses PyTorch 1.7.1. Unfortunately, this proved to be an issue for me, as I could not get Nvidia&rsquo;s mainline to work. Fortunately, there was <a href=https://github.com/woctezuma/stylegan2-ada-pytorch.git>a fork</a> to add support for PyTorch 2 from Github user <code>woctezuma</code>. Thank you, <code>woctezuma</code>.</p><p>Even after sorting the runtime and environment issues out, however, all was not well. Due to my several attempts at training at this point, I had caused the Google Drive host for the CelebA dataset to reach its quota for 24 hours. After waiting until it was freed up again, now <code>torchvision</code> was causing some issue (likely due to the version on my instance being outdated) where the Google Drive response would not be the data, but rather a virus scan page stating that Google could not verify the integrity of the data and asking if I wanted to proceed.</p><pre><code>/opt/conda/lib/python3.10/site-packages/torchvision/datasets/utils.py:260:
UserWarning: We detected some HTML elements in the downloaded file. This most likely means that the download triggered an unhandled API response by GDrive. 
Please report this to torchvision at https://github.com/pytorch/vision/issues including the response:
</code></pre><p>Unfortunately, <code>torchvision</code> offered no support to accept this prompt, so I had to upload my local copy of CelebA to the instance, which added an extra 30 minutes to my rental time.</p><p>This issue really highlights some of the specific challenges with ML workloads that are not faced in typical programming: it is not only that the computation required is many times more expensive, but also that the data sizes involved are also larger (thus running into network bandwidth limitations). This breaks the usual classification of programs into either &ldquo;I/O-bound&rdquo; or &ldquo;compute-bound&rdquo; processes, since ML training is both! (Not to even mention storage-bound.) And because there is a very real chance of exhausting system resources, this makes frequent check-pointing all the more important. You should checkpoint any and all information needed to restart without issue: epoch, step, loss history, and of course the model weights themselves.</p><p>After running for 5,000 kimg and 20.5 hours, the (cherry-picked) results are below.</p><p><img src=stylegan2.jpg alt="A grid of 16 celebrity faces"></p><p>The countless optimizations that make up StyleGAN2 are too extensive to relate here, but if you are interested, I strongly recommend the paper. With a training time of 20.5 hours and at a GPU rental cost of \$0.475 per hour, the total cost for training this round was \$9.74. Not bad!</p><h2 id=shellgan>ShellGAN</h2><p><strong>Time</strong>: 1 week</p><p>After my initial experiments with CelebA, I was still left somewhat disappointed that I wasn&rsquo;t getting the astounding, hyperrealistic images we see from SOTA diffusion models today. Sure, <a href=https://thispersondoesnotexist.com>thispersondoesnotexist.com</a> could do a pretty amazing job, being bankrolled by Nvidia and unimaginably more computing resources than I could ever afford. But was there a way to use GANs as I had the resources to train and generate truly high fidelity, original images? My inspiration came after actually looking at some samples from the CelebA dataset and realizing that it - and human faces in general - were rather ambitious. The images were extremely diverse in poses, angles, backgrounds, and lighting; getting GANs in particular to stablize on something with as many easily identifiable features as the face was tricky; and humans literally have <a href=https://en.wikipedia.org/wiki/Fusiform_face_area>specialized neural hardware</a> just for recognizing faces, so we are extremely discerning on an instinctual level. That was when I came across a <a href=https://nicknewberg.com/GAN-explorations>GAN showcase</a> trained on - among other things - sea shells. Sea shells were the perfect solution to the issues I was seeing. They were detailed but rather abstract, with human evaluators being a lot less likely to immediately notice whether a certain shell was &ldquo;off.&rdquo; However, they weren&rsquo;t boring blobs either. Shells are still beautiful and pleasant to look at. Luckily, I was able to find and collect a dataset which also eliminated some of the problems I had with CelebA: uniform posing and lighting with very limited background diversity.</p><h3 id=data>Data</h3><p>I found it helpful to, instead of scraping the site, traversing and downloading as you go (like a human would), to rather scrape and collect only the image sources (URLs) into a file for later use. This way you have more control over how you want to download (backoffs, naming schemes, a pre-known idea of how many files you will be downloading) as well as making it lower stakes for the scraping process itself, since if you make a mistake in your webscraper, you don&rsquo;t need to repeat downloading images. I had to learn this through trial-and-error, but it was extremely beneficial to use <code>try-except</code> blocks to continue most work even if a few pages had an unexpected format or network issues. You can then note all failed pages or image downloads in a separate log for analysis and retry. If I had to extract these lessons out to a few general guidelines, they would be:</p><ul><li>Log program state in files frequently</li><li>Handle errors gracefully and diligently</li><li>Separate out &ldquo;pre-scraping&rdquo; metadata and actual data downloading</li></ul><h3 id=training>Training</h3><p>I ran the training loop for 4,600 kimg for 25 hours using 1 Nvidia RTX 3090 GPU with 72 GB of disk storage for the considerable dataset size. Seeing as my raw dataset was 300 x 300 pixel images, it was quite natural to rescale to 256 pixels. However, I did have to truncate the full dataset slightly from 202,736 images to only 200,000 due to GPU RAM constraints. Given the scale of the dataset, this was acceptable. Learning from my previous experience training on CelebA, I made sure to allocate adequate resources for this run, in both memory and disk space. You might have noticed that I terminated slightly earlier than the 5,000 kimg mentioned by Nvidia as a reasonable stopping point. This is because, as I suspected, the shell images were far easier to get &ldquo;reasonable&rdquo; results from than Nvidia&rsquo;s facial datasets, so I was already more than satisfied by the 4,600 kimg mark.</p><h3 id=results>Results</h3><p>After a long string of questionable results with GANs on CelebA, I am pleased to say that &ldquo;ShellGAN&rdquo; performed exactly as envisioned. These are the results picked from the 4,600 kimg tick.</p><p><img src=shellgan.jpg alt="Grid of generated shell images"></p><p>And some additional seed generation close-ups. Unfortunately, I wasn&rsquo;t able to reproduce a green shell, which was my favorite color from the results.</p><figure><img src=./shellgan_seed0078.png><figcaption>Seed 78</figcaption></figure><figure><img src=./shellgan_seed0375.png><figcaption>Seed 375</figcaption></figure><figure><img src=./shellgan_seed21313.png><figcaption>Seed 21313</figcaption></figure><p>Nvidia also provided some really cool, easy to use projection capabilities in their StyleGAN2 repo. Projection is taking a given input image and finding some latent space vector which, when passed through the generator, produces a similar image according to some metric. For this implementation, Nvidia chose to use VGG16 perceptual loss, which is a standard convolutional neural network (CNN) architecture that gained a lot of popularity after release. Given some image $I$, we want to find a latent space vector $w$ such that</p>$$
w = \arg \min_{\mathbf{w^*}} \mathcal{L}(G(\mathbf{w^*}), I)
$$<p>I chose an image of a frog because it is roughly the same shape and dimensions as a shell (short, round), with some textured skin and somewhat natural coloring. Also, as described earlier, the green shells were my favorite so I wanted more of those. Below is the progress video of the optimization process, trying to find the $w$ vector and display $G(w)$ at each step (out of 1,000).</p><video width=100% height=auto loop mute controls playsinline>
<source src=./projection_frog.mp4 type=video/mp4></video><p>I also tried an eye for similar reasons. It also has a similar black background with one object in the center focus.</p><video width=100% height=auto loop mute controls playsinline>
<source src=./projection_eye.mp4 type=video/mp4></video><h2 id=conclusion>Conclusion</h2><p>As my first foray into generative models, these experiments were not just highly enlightening but really fun. It is an amazing blend of technical challenges with immediately interpretable visual results which is exciting, especially to motivate you through numerous PyTorch or CUDA errors. As amazing as these results were, however, GANs are still really only the first step in the generative model journey for me. Next, I will be experimenting with diffusion models which have produced some astounding results and address many of the problems from GANs.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Goodfellow, Ian J., Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron C. Courville, and Yoshua Bengio. &ldquo;Generative adversarial nets&rdquo;. <em>Advances in neural information processing systems</em> 27 (2014). <a href=https://arxiv.org/pdf/1406.2661>https://arxiv.org/pdf/1406.2661</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Radford, Alec, Luke Metz, and Soumith Chintala. &ldquo;Unsupervised representation learning with deep convolutional generative adversarial networks.&rdquo; <em>arXiv preprint arXiv:1511.06434</em> (2015). <a href=https://arxiv.org/pdf/1511.06434>https://arxiv.org/pdf/1511.06434</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Arjovsky, Martin, Soumith Chintala, Léon Bottou. &ldquo;Wasserstein GAN.&rdquo; <em>International conference on machine learning</em> (2017). <a href=https://arxiv.org/pdf/1701.07875>https://arxiv.org/pdf/1701.07875</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Karras, Tero, Samuli Laine, Miika Aittala, Janne Hellsten, Jaakko Lehtinen, and Timo Aila. &ldquo;Analyzing and improving the image quality of stylegan.&rdquo; <em>Proceedings of the IEEE/CVF conference on computer vision and pattern recognition</em> (2020). <a href=https://arxiv.org/pdf/1912.04958>https://arxiv.org/pdf/1912.04958</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Huang, Xun, and Serge Belongie. &ldquo;Arbitrary style transfer in real-time with adaptive instance normalization.&rdquo; <em>Proceedings of the IEEE international conference on computer vision</em> (2017). <a href=https://arxiv.org/pdf/1703.06868>https://arxiv.org/pdf/1703.06868</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer></footer></body></html>